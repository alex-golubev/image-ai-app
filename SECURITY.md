# Security Guide

This document outlines the security measures implemented in this application and best practices for maintaining security.

## üîê Password Security

### Current Implementation

- **bcrypt Hashing**: All passwords are hashed using bcrypt with 12 salt rounds
- **No Plain Text Storage**: Passwords are never stored in plain text
- **Unique Salt**: Each password gets a unique salt automatically generated by bcrypt

### How bcrypt Salt Storage Works

**Q: Is it safe to store salt with the hash?**
**A: Yes, absolutely! Here's why:**

#### Salt is NOT a secret

```typescript
// bcrypt automatically embeds salt in the hash:
const hash = await bcrypt.hash('password123', 12);
// Result: $2b$12$LQv3c1yqBwcVsvDwjDjinOuiwuIsrdhvfkUXNYPgYvqcxpCRZVzq6
//         ^^^^    ^^^^^^^^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//         alg     salt (22 chars)         hash (31 chars)
```

**Q: Is it safe to store SALT_ROUNDS as a constant in code?**
**A: Yes, absolutely! Here's why:**

#### SALT_ROUNDS is NOT a secret

```typescript
// This is perfectly safe and standard practice:
const SALT_ROUNDS = 12;

// The rounds are visible in every hash anyway:
// $2b$12$... ‚Üê The "12" is public information
//      ^^
```

#### Why this is secure:

1. **Public Information**: Rounds are embedded in every hash
2. **Not Security Through Obscurity**: Security comes from computational cost, not hiding the algorithm
3. **Industry Standard**: All major applications store rounds as constants
4. **Transparency**: Allows security audits and performance tuning

#### What rounds actually do:

- **12 rounds = 2^12 = 4,096 iterations**
- Makes each hash take ~100-300ms to compute
- Scales exponentially: 13 rounds = 2x slower, 14 rounds = 4x slower
- Prevents brute force attacks by making them computationally expensive

#### Recommended values:

- **10 rounds**: Minimum for production (2024)
- **12 rounds**: Current recommendation ‚úÖ
- **14+ rounds**: For high-security applications
- **Adjust based on**: Server performance and security requirements

#### Why this is secure:

1. **Prevents Rainbow Tables**: Each password gets a unique salt
2. **No Secret Required**: Salt's job is uniqueness, not secrecy
3. **Industry Standard**: Used by all major applications (Google, Facebook, etc.)
4. **Computational Cost**: 12 rounds = 4096 iterations make brute force slow

#### What attackers would need:

- Access to your database (already a major breach)
- Massive computational resources for brute force
- Time: billions of years for strong passwords

### Password Requirements

- Minimum 8 characters
- At least one uppercase letter (A-Z)
- At least one lowercase letter (a-z)
- At least one number (0-9)
- At least one special character (!@#$%^&\*()\_+-=[]{}|;:,.<>?)

### Security Comparison

| Method        | Salt Storage     | Security Level | Notes                       |
| ------------- | ---------------- | -------------- | --------------------------- |
| **bcrypt** ‚úÖ | Embedded in hash | Very High      | Industry standard           |
| MD5 + Salt    | Separate         | Low            | Deprecated, too fast        |
| SHA256 + Salt | Separate         | Medium         | Too fast without iterations |
| Argon2        | Embedded         | Very High      | Newer alternative to bcrypt |

## üõ°Ô∏è Authentication Security

### Rate Limiting

- **Failed Login Protection**: Maximum 5 failed attempts per IP within 15 minutes
- **Automatic Blocking**: IP addresses are blocked for 30 minutes after exceeding the limit
- **Timing Attack Protection**: Authentication always performs password verification to prevent timing-based attacks

### Error Handling

- **Generic Error Messages**: Authentication failures return generic "Invalid email or password" messages
- **No User Enumeration**: The system doesn't reveal whether an email exists or not
- **Proper HTTP Status Codes**: Uses appropriate tRPC error codes (UNAUTHORIZED, TOO_MANY_REQUESTS)

## üåê Network Security

### IP Address Detection

The application detects client IP addresses from multiple headers:

- `x-forwarded-for` (primary)
- `x-real-ip`
- `cf-connecting-ip` (Cloudflare)
- `x-client-ip`
- Fallback to `127.0.0.1` for development

### Headers Security

- Client IP is extracted safely with proper parsing
- Multiple proxy headers are supported for different deployment scenarios

## üìä Data Validation

### Input Validation

- **Email Validation**: Proper email format validation using Zod schemas
- **Password Validation**: Strong password requirements enforced
- **UUID Validation**: All user IDs are validated as proper UUIDs
- **SQL Injection Prevention**: Using Drizzle ORM with parameterized queries

### Output Sanitization

- **Password Exclusion**: Passwords are never returned in API responses
- **Selective Field Return**: Only necessary user fields are returned (id, name, email, avatar)

## üîß Implementation Details

### Database Security

```typescript
// Passwords are automatically hashed before storage
const hashedPassword = await hashPassword(input.password);
await db.insert(users).values({
  ...input,
  password: hashedPassword,
});
```

### Authentication Flow

```typescript
// Rate limiting check
if (authRateLimiter.isRateLimited(clientIP)) {
  throw new TRPCError({ code: 'TOO_MANY_REQUESTS' });
}

// Timing attack protection
const passwordToVerify = result?.password || '$2b$12$dummyhash...';
const isValid = await verifyPassword(password, passwordToVerify);
```

## ‚ö†Ô∏è Security Considerations

### Current Limitations

1. **In-Memory Rate Limiting**: Rate limiting data is stored in memory and will reset on server restart
2. **No Session Management**: No JWT tokens or session management implemented yet
3. **No HTTPS Enforcement**: HTTPS should be enforced in production
4. **No CSRF Protection**: Consider implementing CSRF tokens for state-changing operations

### Production Recommendations

1. **Use Redis for Rate Limiting**: Replace in-memory rate limiter with Redis for persistence
2. **Implement JWT/Sessions**: Add proper session management
3. **Add HTTPS Enforcement**: Force HTTPS in production
4. **Environment Variables**: Store sensitive configuration in environment variables
5. **Logging**: Implement security event logging
6. **Monitoring**: Set up alerts for suspicious activities

## üöÄ Deployment Security

### Environment Variables

```bash
# Required
DATABASE_URL=postgresql://...

# Recommended for production
NODE_ENV=production
BCRYPT_ROUNDS=12
RATE_LIMIT_MAX_ATTEMPTS=5
RATE_LIMIT_WINDOW_MS=900000  # 15 minutes
RATE_LIMIT_BLOCK_DURATION_MS=1800000  # 30 minutes
```

### Production Checklist

- [ ] HTTPS enabled
- [ ] Environment variables configured
- [ ] Database connection secured
- [ ] Rate limiting configured appropriately
- [ ] Logging and monitoring set up
- [ ] Regular security updates scheduled

## üìù Security Testing

The application includes comprehensive security tests:

- Password hashing and verification
- Rate limiting functionality
- Authentication flow security
- Input validation
- Error handling

Run security tests:

```bash
npm test -- --testPathPattern="password|rate-limiter|user"
```

## üêõ Reporting Security Issues

If you discover a security vulnerability, please:

1. **Do not** open a public issue
2. Email security concerns to the maintainers
3. Provide detailed information about the vulnerability
4. Allow time for the issue to be addressed before public disclosure

## üìö Additional Resources

- [OWASP Top 10](https://owasp.org/www-project-top-ten/)
- [bcrypt Documentation](https://github.com/kelektiv/node.bcrypt.js)
- [tRPC Security Best Practices](https://trpc.io/docs/server/error-handling)
- [Next.js Security](https://nextjs.org/docs/advanced-features/security-headers)
